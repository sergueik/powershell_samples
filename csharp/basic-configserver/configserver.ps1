#Copyright (c) 2023 Serguei Kouzmine
#
#Permission is hereby granted, free of charge, to any person obtaining a copy
#of this software and associated documentation files (the "Software"), to deal
#in the Software without restriction, including without limitation the rights
#to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
#copies of the Software, and to permit persons to whom the Software is
#furnished to do so, subject to the following conditions:
#
#The above copyright notice and this permission notice shall be included in
#all copies or substantial portions of the Software.
#
#THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
#IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
#FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
#AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
#LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
#OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
#THE SOFTWARE.

param (
  [string]$documentRoot = '',
  [switch]$gui,
  [switch]$debug
)

# see also: https://www.cyberforum.ru/powershell/thread1794721.html#post9502065
# see also
# Wait-Event
# https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/wait-event?view=powershell-7.2
# installed from Module: "Microsoft.PowerShell.Utility" with  Powershell 5.0 and ealier
# https://docs.microsoft.com/en-us/previous-versions/powershell/module/microsoft.powershell.utility/wait-event?view=powershell-5.0

function custom_pause {
  param(
    [bool]$fullstop,
    [string]$message = $null, # optional, e.g. 'Press any key to continue...'
    [int]$timeout = 1000
  )
  # Do not close Browser / Selenium when run from Powershell ISE
  if ($fullstop) {
    try {
      if ($message -ne '') {
         write-host $message -nonewline
      } else {
        Write-Output 'pause'
      }
      [void]$host.UI.RawUI.ReadKey('NoEcho,IncludeKeyDown')
    } catch [exception]{}
  } else {
    Start-Sleep -Millisecond $timeout
  }
}

# based on:
# http://blogs.msdn.com/b/virtual_pc_guy/archive/2010/09/23/a-self-elevating-powershell-script.aspx
function check_elevation {

  param(
    [string]$message,
    [bool]$debug
  )

  $myWindowsID = [System.Security.Principal.WindowsIdentity]::GetCurrent()
  $myWindowsPrincipal = new-object System.Security.Principal.WindowsPrincipal($myWindowsID)

  $adminRole=[System.Security.Principal.WindowsBuiltInRole]::Administrator 
  if ($debug ){
    Write-Host -NoNewLine 'Press any key to continue...'
    $null = $Host.UI.RawUI.ReadKey('NoEcho,IncludeKeyDown')
  }

  # Check to see if we are currently NOT running "as Administrator"
  if ( -not $myWindowsPrincipal.IsInRole($adminRole) ) {
    write-host -foreground 'Red' ('The {0} needs to run in elevated prompt' -f $message) 
    exit
  }
}

function custom_pause_gui {
  param(
    [string]$text,
    [object]$caller
  )
  # form element layot generated by form_builder.ps1
    
  Add-Type -AssemblyName System.Windows.Forms
  Add-Type -AssemblyName System.Drawing
  $f = new-object System.Windows.Forms.Form
  $f.Text = 'Stop'
  $f.Size = new-object System.Drawing.Size(152,162)
    
  $f.FormBorderStyle = [System.Windows.Forms.BorderStyle]::FixedSingle
  $f.SuspendLayout()

  $t = new-object System.Windows.Forms.TextBox
  $t.Text = $text
  $t.Top = 30
  $t.Left = 60
  $t.Anchor = 'Left,Top'
  $t.Size = new-object System.Drawing.Size(60,23)
  $f.Controls.Add($t)
        

  $b = new-object System.Windows.Forms.Button
  $b.Text = 'Stop Server'
  $b.Top = 64
  $b.Left = 30
  $b.Anchor = 'Left,Top'
  $b.Size = new-object System.Drawing.Size(90,23)
  $f.Controls.Add($b)
  $b.add_click({
    $f.Close()
  })


  $l = new-object System.Windows.Forms.Label
  $l.Text = 'Port'
  $l.Top = '32'
  $l.Left = '20'
  $l.Anchor = 'Left,Top'
  $l.Size = new-object System.Drawing.Size(100,23)
  $f.Controls.Add($l)

  [void]$f.ShowDialog([System.Windows.Forms.IWin32Window]($caller))
  $f.Dispose()
}



# http://poshcode.org/2887
# http://stackoverflow.com/questions/8343767/how-to-get-the-current-directory-of-the-cmdlet-being-executed
# https://msdn.microsoft.com/en-us/library/system.management.automation.invocationinfo.pscommandpath%28v=vs.85%29.aspx
function Get-ScriptDirectory {
  [string]$scriptDirectory = $null

  if ($host.Version.Major -gt 2) {
    $scriptDirectory = (Get-Variable PSScriptRoot).Value
    Write-Debug ('$PSScriptRoot: {0}' -f $scriptDirectory)
    if ($scriptDirectory -ne $null) {
      return $scriptDirectory;
    }
    $scriptDirectory = [System.IO.Path]::GetDirectoryName($MyInvocation.PSCommandPath)
    Write-Debug ('$MyInvocation.PSCommandPath: {0}' -f $scriptDirectory)
    if ($scriptDirectory -ne $null) {
      return $scriptDirectory;
    }

    $scriptDirectory = Split-Path -Parent $PSCommandPath
    Write-Debug ('$PSCommandPath: {0}' -f $scriptDirectory)
    if ($scriptDirectory -ne $null) {
      return $scriptDirectory;
    }
  } else {
    $scriptDirectory = [System.IO.Path]::GetDirectoryName($MyInvocation.MyCommand.Definition)
    if ($scriptDirectory -ne $null) {
      return $scriptDirectory;
    }
    $Invocation = (Get-Variable MyInvocation -Scope 1).Value
    if ($Invocation.PSScriptRoot) {
      $scriptDirectory = $Invocation.PSScriptRoot
    } elseif ($Invocation.MyCommand.Path) {
      $scriptDirectory = Split-Path $Invocation.MyCommand.Path
    } else {
      $scriptDirectory = $Invocation.InvocationName.Substring(0,$Invocation.InvocationName.LastIndexOf('\'))
    }
    return $scriptDirectory
  }
}


$utility_class = 'SimpleHTTPServer'

if (-not ($utility_class -as [type])) {

  # based on:
  # https://gist.github.com/aksakalli/9191056
  #
  # see also:
  # https://aksakalli.github.io/2014/02/24/simple-http-server-with-csparp.html
  # https://github.com/unosquare/embedio
  # https://github.com/bonesoul/uhttpsharp
  
  Add-Type -TypeDefinition @"
using System;

using System.Collections.Generic;
using System.Collections.Specialized;
using System.Collections;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Net.Sockets;
using System.Net;
using System.Security.Cryptography;
using System.Text.RegularExpressions;
using System.Text;
using System.Threading;


public class ${utility_class} {

  private NameValueCollection queryString = new NameValueCollection();
  private String hash = null;
  private  string fileName = null;

  private Thread _serverThread;
  private string documentRoot;
  private HttpListener _listener;
  private int port;

  public int Port {
    get { return port; }
  }

  public ${utility_class}(string documentRoot, int port) {
    this.Initialize(documentRoot, port);
  }

  public ${utility_class}(string documentRoot) {
    // find an unused TCP port
    var tcpListener = new TcpListener(IPAddress.Loopback, 0);
    tcpListener.Start();
    int unusedPort = ((IPEndPoint)tcpListener.LocalEndpoint).Port;
    tcpListener.Stop();
    this.Initialize(documentRoot, unusedPort);
  }
  
  private void Initialize(string documentRoot, int port) {
    this.documentRoot = documentRoot;
    this.port = port;
    _serverThread = new Thread(this.Listen);
    _serverThread.Start();
  }

  public void Stop() {
    _serverThread.Abort();
    _listener.Stop();
  }

  private void Listen() {
    _listener = new HttpListener();
    _listener.Prefixes.Add("http://*:" + port.ToString() + "/");
    _listener.Start();
    while (true) {
      try {
        HttpListenerContext context = _listener.GetContext();
        Process(context);
      } catch (Exception) {

      }
    }
  }

  // origin: http://www.java2s.com/Code/CSharp/Security/GetMD5Hash.htm
  public static string getMD5Hash(byte[] inputBytes) {
    MD5 md5 = MD5.Create();
    
    byte[] hash = md5.ComputeHash(inputBytes);
    var stringBuilder = new StringBuilder();
    for (int i = 0; i < hash.Length; i++) {
      stringBuilder.Append(hash[i].ToString("X2"));
    }
    return stringBuilder.ToString();
  }
  
  private void Process(HttpListenerContext context) {
    
    if (String.Compare(context.Request.HttpMethod, "GET", StringComparison.OrdinalIgnoreCase) != 0) {
      Console.Error.WriteLine(String.Format("not implemented: {0}", context.Request.HttpMethod));
      context.Response.StatusCode = (int)HttpStatusCode.NotImplemented;
      context.Response.OutputStream.Flush();
      context.Response.OutputStream.Close();
      return;
    }
    queryString = context.Request.QueryString;
    if (queryString.AllKeys.Contains("filename")) {
      fileName = queryString["filename"];
      Console.Error.WriteLine(String.Format("filename: {0}", fileName));      
    }
    if (queryString.AllKeys.Contains("hash")) {
      hash = queryString["hash"];
      Console.Error.WriteLine(String.Format("hash: {0}", hash));      
    } else {
      hash = "";
    }
    String filePath = Path.Combine(documentRoot, fileName);
    Console.Error.WriteLine(String.Format("inspect file: {0}", filePath));
    if (File.Exists(filePath)) {
      try {
        byte[] fileBytes = File.ReadAllBytes(filePath);
        String fileHash = getMD5Hash(fileBytes);
        if (string.IsNullOrEmpty(hash) || String.Compare(hash, fileHash, StringComparison.OrdinalIgnoreCase) != 0) {
          Console.Error.WriteLine(String.Format("Return {0}", filePath));
          string mime;
          context.Response.ContentType = mimeTypes.TryGetValue(Path.GetExtension(filePath), out mime) ? mime : "application/octet-stream";
          // https://stackoverflow.com/questions/32537219/error-httpwebrequest-bytes-to-be-written-to-the-stream-exceed-the-content-len
          context.Response.ContentLength64 = fileBytes.Length;
          context.Response.AddHeader("Date", DateTime.Now.ToString("r"));
          context.Response.AddHeader("Last-Modified", System.IO.File.GetLastWriteTime(filePath).ToString("r"));
          context.Response.AddHeader("Hash", fileHash);
          Console.Error.WriteLine(String.Format("Send {0} bytes", fileBytes.Length));
           
          context.Response.OutputStream.Write(fileBytes, 0, fileBytes.Length);
          context.Response.OutputStream.Flush();

          context.Response.StatusCode = (int)HttpStatusCode.OK;
        } else {
          Console.Error.WriteLine(String.Format("Unmodified: {0}", fileName));
          context.Response.StatusCode = (int)HttpStatusCode.NotModified;
          context.Response.OutputStream.Flush();
        }

          
      } catch (Exception e) {
        Console.Error.WriteLine(String.Format("Exception: {0}", e.ToString()));
        context.Response.StatusCode = (int)HttpStatusCode.InternalServerError;
      }

    } else {
      Console.Error.WriteLine(String.Format("Processing hash error: {0}", hash));      
      context.Response.StatusCode = (int)HttpStatusCode.NotFound;
    }
      
    context.Response.OutputStream.Close();
  }

  
  private static IDictionary<string, string> mimeTypes = new Dictionary<string, string>(StringComparer.InvariantCultureIgnoreCase) {
  #region extension to MIME type list
    { ".css", "text/css" },
    { ".gif", "image/gif" },
    { ".htm", "text/html" },
    { ".html", "text/html" },
    { ".ico", "image/x-icon" },
    { ".jpeg", "image/jpeg" },
    { ".jpg", "image/jpeg" },
    { ".js", "application/x-javascript" },
    { ".json", "application/json" },
    { ".png", "image/png" },
    { ".txt", "text/plain" },
   #endregion
  };
}
"@
}

$debug_flag = [bool]$PSBoundParameters['debug'].IsPresent -bor $debug.ToBool()

check_elevation -debug $debug_flag -message 'HTTP Server'
# custom code instead of resolve-path
if ($documentRoot -eq '') { 
  $documentRoot = (Get-ScriptDirectory)
} elseif (($documentRoot  -match '^\.\\') -or ($documentRoot  -match '^\./')) {
  $documentRoot = ((Get-ScriptDirectory) + '\' + $documentRoot ) 
}
write-host ('probing {0}' -f $documentRoot )
if (-not (test-path -path $documentRoot )) { 
  wite-host ( 'cannot continue bad {0} is specified' -f  $documentRoot)
  exit 
}
$o = new-object $utility_class($documentRoot)
write-output $o.Port
$caller_class = 'Win32Window_2'
if (-not ($caller_class -as [type])) {
Add-Type -TypeDefinition @"
using System;
using System.Windows.Forms;
public class ${caller_class}: IWin32Window {
  private IntPtr _hWnd;
  public ${caller_class}(IntPtr handle) {
    _hWnd = handle;
  }

  public IntPtr Handle {
    get { return _hWnd; }
  }
}
"@ -ReferencedAssemblies 'System.Windows.Forms.dll'
}

$w = [System.Diagnostics.Process]::GetCurrentProcess().MainWindowHandle

$caller = new-object $caller_class -ArgumentList ($w)

if ([bool]$PSBoundParameters['gui'].IsPresent ) {
  custom_pause_gui -text $o.Port -caller $caller
}  else {
  start-sleep -seconds 1
  custom_pause -fullstop $true -message ( 'press any key to stop the server' + ( [char]10)) 
}

$o.Stop()
