<html>

<head>
<meta http-equiv="Content-Language" content="en-us">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<title>Writing a Basic Web Server</title>
</head>

<body>

<p>Writing a Basic Web Server</p>
<p>
<img border="0" src="ws1.png" width="338" height="207"></p>
<h2>Introduction</h2>
<p>Mainly for the fun of it, I decided to look into what's involved in writing 
my own web server.&nbsp; I quickly became enthralled with the idea and the 
fascinating things I was discovering about browsers, compliance with browser 
expectations in the responses, and the sheer pleasure of writing a lean and mean 
web server.&nbsp; So, this article (as requested a few weeks ago by several 
people) describes the process.&nbsp; At this point, the implementation supports:</p>
<ul>
	<li>Routing</li>
	<li>Session Manager</li>
	<li>Authorization</li>
	<li>Expired Sessions</li>
</ul>
<p>Because the web server is so lightweight, I found it completely unnecessary 
to do anything complicated like implementing plug-ins for the actual 
application.&nbsp; There's three core files:</p>
<ul>
	<li>Listener.cs - Listens and responds to connections using HttpListener</li>
	<li>Router.cs - Manages routing</li>
	<li>SessionManager.cs - Manages connection sessions state</li>
</ul>
<h3>A Soapbox Moment (or several)</h3>
<p>I think it's important to state what this web server <i>is not.</i>&nbsp; 
What you won't find (and you may disagree with my severe criticisms, but this 
what I've learned over the last few years of web development):</p>
<ul>
	<li>Anything ORM.&nbsp; ORM should absolutely never be part of a web server</li>
	<li>Anything MVC.&nbsp; The whole MVC concept for web apps is a useless 
	architecture designed to make Ruby on Rails developers comfortable with 
	Microsoft technologies.&nbsp; Totally useless and unnecessary.</li>
	<li>No runtime compilation of web pages or custom syntaxes for parsing 
	&quot;enhanced&quot; HTML files.&nbsp; Given modern jQuery-based controls like 
	jqwidgets and employing JSON and AJAX, the need for turning an HTML file 
	into something imperative by embedding C# (or other language) elements, 
	well, that just isn't necessary.&nbsp; It:<ul>
		<li>slows down serving the page</li>
		<li>smears the logic that determines view state into the view where 
		usually shouldn't belong</li>
		<li>and if it's necessary to write a complex rendering, this is better 
		done in a decent fluid-like architecture rather than syntaxes that 
		further obfuscate the already arcane syntax of HTML and CSS.</li>
	</ul>
	</li>
	<li>Attributes - I've said it since I started working with C#: attributes 
	are great for giving a serializer hints for how to serialize fields or 
	properties, other than that, they mostly promote bad design -- design which 
	would be much better served with good object oriented design.&nbsp; For 
	example, my routes are implemented by a <code>Route</code> base class and 
	<code>AuthenticatedRoute</code> child class.&nbsp; If you want role-based authentication, 
	it becomes a derived class rather than an attribute that decorates often 
	empty controller functions and that requires hoops to go through to 
	implement something different than what the framework designers decided 
	would be the right implementation.&nbsp; Throw that all away, because it 
	never works the way you want it, and it adds more performance bloat 
	constantly using reflection to check &quot;oh, am I authorized&quot;, &quot;oh, do I have 
	the right role for this?&quot;&nbsp; Again, another example of horrid design.</li>
	<li>No IIS.&nbsp; More unnecessary bloat and configuration complexity that 
	isn't needed.</li>
</ul>
<p>The ironic thing (and this is the last I'll say of it while standing on my 
soapbox) is that, having implemented my own web server, I've come to realize how 
much technologies like MVC Razor and Ruby on Rails (to pick two) <i>get in the 
way </i>of the business of serving web pages and giving the programmer control 
over how to render non-static content.&nbsp; With a simple web server, I find 
myself focusing much more on the client-side JavaScript, HTML, and components, 
where the only attention I have to pay to the server-side process is the PUT 
handlers and the occasional AJAX request.&nbsp; The baggage created by MVC, 
arcane routing syntaxes, attributes decorating unnecessary controller 
functions--well, the whole state of affairs of writing a web application is 
rather dismal, in my opinion.</p>
<h3>About the Source Code Repository</h3>
<p>The source code is hosted on GitHub:</p>
<pre>git clone <a href="https://github.com/cliftonm/BasicWebServer.git">https://github.com/cliftonm/BasicWebServer.git</a></pre>
<h3>About the Process of this Article</h3>
<p>Rather than just showing you the final web server, I think it's much more 
interesting to document, step by step, the construction of the web server, so 
you can get a feel for how it is built from a blank slate, the design and 
implementation decisions (good or bad) and the overall process.&nbsp; I hope 
you, the reader, enjoy this approach.</p>
<h2>Step 1 - HttpListener</h2>
<p>The first step of process is to get an <code>HttpListener</code> class working.&nbsp; 
I opted to go this route rather than the lower level socket route because 
<code>HttpListener</code> provides a lot of useful services, such as decoding the HTML 
request.&nbsp; I've read that it's not as performant as going the socket route, 
but I'm not overly concerned with a little performance reduction.</p>
<p>The web server is implemented as a library.&nbsp; There is a console application 
for the specific web application executable.&nbsp; For this first step, the web 
server needs:</p>
<pre>using System.Net;
using System.Net.Sockets;
using System.Threading;</pre>
<p>Because a web server is primarily stateless (except for session objects) most 
of behaviors can be implemented as static singletons.&nbsp; </p>
<pre>namespace Clifton.WebServer
{
  /// &lt;summary&gt;
  /// A lean and mean web server.
  /// &lt;/summary&gt;
  public static class Server
  {
    private static HttpListener listener;
    ...</pre>
<p>We're going to make 
the initial assumption that we're connecting to the server on an intranet, so we 
obtain the IP's of our local host:</p>
<pre>/// &lt;summary&gt;
/// Returns list of IP addresses assigned to localhost network devices, such as hardwired ethernet, wireless, etc.
/// &lt;/summary&gt;
private static List&lt;IPAddress&gt; GetLocalHostIPs()
{
  IPHostEntry host;
  host = Dns.GetHostEntry(Dns.GetHostName());
  List&lt;IPAddress&gt; ret = host.AddressList.Where(ip =&gt; ip.AddressFamily == AddressFamily.InterNetwork).ToList();

  return ret;
}</pre>
<p>We then instantiate the HttpListener and add the localhost prefixes:</p>
<pre>private static HttpListener InitializeListener(List&lt;IPAddress&gt; localhostIPs)
{
  HttpListener listener = new HttpListener();
  listener.Prefixes.Add(&quot;http://localhost/&quot;);

  // Listen to IP address as well.
  localhostIPs.ForEach(ip =&gt;
  {
    Console.WriteLine(&quot;Listening on IP &quot; + &quot;http://&quot; + ip.ToString() + &quot;/&quot;);
    listener.Prefixes.Add(&quot;http://&quot; + ip.ToString() + &quot;/&quot;);
  });

  return listener;
}</pre>
<p>You will probably have more than one localhost IP.&nbsp; For example, my 
laptop has an IP for both the ethernet and wireless &quot;ports.&quot;</p>
<p>Borrowing a concept from Sacha's
<a href="http://www.codeproject.com/Articles/826383/REST-A-Simple-REST-framework?msg=4969159#xx4969159xx">
A Simple REST Framework</a>, we'll set up a semaphore that waits for a specified 
number of simultaneously allowed connections:</p>
<pre>public static int maxSimultaneousConnections = 20;
private static Semaphore sem = new Semaphore(maxSimultaneousConnections, maxSimultaneousConnections);</pre>
<p>This is implemented in a worker thread, which is invoked with Task.Run:</p>
<pre>/// &lt;summary&gt;
/// Begin listening to connections on a separate worker thread.
/// &lt;/summary&gt;
private static void Start(HttpListener listener)
{
  listener.Start();
  Task.Run(() =&gt; RunServer(listener));
}</pre>
<pre>/// &lt;summary&gt;
/// Start awaiting for connections, up to the &quot;maxSimultaneousConnections&quot; value.
/// This code runs in a separate thread.
/// &lt;/summary&gt;
private static void RunServer(HttpListener listener)
{
  while (true)
  {
    sem.WaitOne();
    StartConnectionListener(listener);
  }
}</pre>
<p>Lastly, we implement the connection listener as an awaitable asynchronous 
process:</p>
<pre>/// &lt;summary&gt;
/// Await connections.
/// &lt;/summary&gt;
private static async void StartConnectionListener(HttpListener listener)
{
  // Wait for a connection. Return to caller while we wait.
  HttpListenerContext context = await listener.GetContextAsync();

  // Release the semaphore so that another listener can be immediately started up.
  sem.Release();

  // We have a connection, do something...
}</pre>
<p>So, let's do something:</p>
<pre>string response = &quot;Hello Browser!&quot;;
byte[] encoded = Encoding.UTF8.GetBytes(response);
context.Response.ContentLength64 = encoded.Length;
context.Response.OutputStream.Write(encoded, 0, encoded.Length);
context.Response.OutputStream.Close();</pre>
<p>And, we need a public <code>Start</code> method:</p>
<pre>/// &lt;summary&gt;
/// Starts the web server.
/// &lt;/summary&gt;
public static void Start()
{
  List&lt;IPAddress&gt; localHostIPs = GetLocalHostIPs();
  HttpListener listener = InitializeListener(localHostIPs);
  Start(listener);
}</pre>
<p>Now in our console app, we can start up the server:</p>
<pre>using System;

using Clifton.WebServer;

namespace ConsoleWebServer
{
  class Program
  {
    static void Main(string[] args)
    {
      Server.Start();
      Console.ReadLine();
    }
  }
}</pre>
<p>and away we go:</p>
<p><img border="0" src="ws1.png" width="338" height="207"></p>
<h3>Always Inspect the Browser's Web Console Window</h3>
<p>The browser's web console window is your friend - it will tell you all the 
things you are doing wrong!&nbsp; For example, in our test case above, we 
discover:</p>
<p><img border="0" src="ws2.png" width="806" height="251"></p>
<p>Here we learn that we need to take care of the encoding, which is done in the 
HTML:</p>
<pre>string response = &quot;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv='content-type' content='text/html; charset=utf-8'/&gt;
      &lt;/head&gt;Hello Browser!&lt;/html&gt;&quot;;</pre>
<p>As this is just an example, we'll leave it at that for now.&nbsp; Later we'll 
learn more things we're doing wrong!</p>
<h2>Step 2 - Logging</h2>
<p>First, let's add some logging, as logging is really useful to see what kind 
of requests are being made of our web server:</p>
<pre>Log(context.Request);</pre>
<pre>/// &lt;summary&gt;
/// Log requests.
/// &lt;/summary&gt;
public static void Log(HttpListenerRequest request)
{
  Console.WriteLine(request.RemoteEndPoint + &quot; &quot; + request.HttpMethod + &quot; /&quot; + request.Url.AbsoluteUri.RightOf('/', 3));
}</pre>
<p>You can also use remote loggers, like PaperTrailApp, which I've written about
<a href="http://www.codeproject.com/Articles/843938/Logging-With-PaperTrail-Directly-In-Your-Applicati">
here</a>.</p>
<p>We add the Log call right after releasing the semaphore:</p>
<pre>Log(context.Request);</pre>
<h3>What we Notice After Adding the Logger</h3>
<p>Once we add the logging, we notice immediately that the browser not only 
requests the page at the default page, but it's also asking for favicon.ico!</p>
<p><img border="0" src="ws3.png" width="302" height="81"></p>
<p>Well, we need to something about that!</p>
<h2>Step 3 - Serving Content: Default Routing</h2>
<p>Obviously, we don't want to code our web pages as strings in C#.&nbsp; So, 
let's create a basic structure for our web application.&nbsp; This is completely 
arbitrary, but what I've chosen as a structure is that everything will derive 
from the folder &quot;Website&quot;.&nbsp; Under &quot;Website&quot;, we find the following folders:</p>
<ul>
	<li>Pages: root of all pages</li>
	<li>CSS: contains all .css and related files</li>
	<li>Scripts: contains all .js files</li>
	<li>Images: contains all image files</li>
</ul>
<p>To handle some basic functionality, we need the beginnings of a router.&nbsp; Our 
first cut will do nothing else than respond with files found in the &quot;Webiste&quot; 
folder and sub-folders as determined by the URL path and the request extension.&nbsp; 
We first extract some information from the URL request:</p>
<pre>HttpListenerRequest request = context.Request;
string path = request.RawUrl.LeftOf(&quot;?&quot;); // Only the path, not any of the parameters
string verb = request.HttpMethod; // get, post, delete, etc.
string parms = request.RawUrl.RightOf(&quot;?&quot;); // Params on the URL itself follow the URL and are separated by a ?
Dictionary&lt;string, string&gt; kvParams = GetKeyValues(parms); // Extract into key-value entries.</pre>
<p>We can now pass this information to the router:</p>
<pre>router.Route(verb, path, kvParams);</pre>
<p>Even though it could be static, there are some potential benefits to making 
the router an actual instance, so we initialize it in the <code>Server</code> class:</p>
<pre>private static Router router = new Router();</pre>
<p>Another nitpicky detail is the actual website path.&nbsp; Because I'm running 
the console program out of a bin\debug folder, the website path is actually 
&quot;..\..\Website&quot;.&nbsp; Here's a clumsy way of getting this path:</p>
<pre>public static string GetWebsitePath()
{
  // Path of our exe.
  string websitePath = Assembly.GetExecutingAssembly().Location;
  websitePath = websitePath.LeftOfRightmostOf(&quot;\\&quot;).LeftOfRightmostOf(&quot;\\&quot;).LeftOfRightmostOf(&quot;\\&quot;) + &quot;\\Website&quot;;

  return websitePath;
}</pre>
<p>
<img border="0" src="refactor.png">A little refactoring is need to We pass this in to the web server, which 
configures the router:</p>
<pre>public static void Start(string websitePath)
{
  router.WebsitePath = websitePath;
  ...</pre>
<p>Since I don't particularly like switch statements, we'll initialize a map of 
known extensions and their loader locations.&nbsp; Consider how different 
functions could be used to load the content from, say, a database.</p>
<pre>public class Router
{
  public string WebsitePath { get; set; }

  private Dictionary&lt;string, ExtensionInfo&gt; extFolderMap;

  public Router()
  {
    extFolderMap = new Dictionary&lt;string, ExtensionInfo&gt;() 
    {
      {&quot;ico&quot;, new ExtensionInfo() {Loader=ImageLoader, ContentType=&quot;image/ico&quot;}},
      {&quot;png&quot;, new ExtensionInfo() {Loader=ImageLoader, ContentType=&quot;image/png&quot;}},
      {&quot;jpg&quot;, new ExtensionInfo() {Loader=ImageLoader, ContentType=&quot;image/jpg&quot;}},
      {&quot;gif&quot;, new ExtensionInfo() {Loader=ImageLoader, ContentType=&quot;image/gif&quot;}},
      {&quot;bmp&quot;, new ExtensionInfo() {Loader=ImageLoader, ContentType=&quot;image/bmp&quot;}},
      {&quot;html&quot;, new ExtensionInfo() {Loader=PageLoader, ContentType=&quot;text/html&quot;}},
      {&quot;css&quot;, new ExtensionInfo() {Loader=FileLoader, ContentType=&quot;text/css&quot;}},
      {&quot;js&quot;, new ExtensionInfo() {Loader=FileLoader, ContentType=&quot;text/javascript&quot;}},
      {&quot;&quot;, new ExtensionInfo() {Loader=PageLoader, ContentType=&quot;text/html&quot;}},
    };
  }
  ....</pre>
<p><img border="0" src="note.png" width="24" height="32">&nbsp; Notice how we 
also handle the &quot;no extension&quot; case, which we implement as assuming that the 
content will be an HTML page.</p>
<p><img border="0" src="note.png" width="24" height="32">&nbsp; Also notice that 
we set the content type.&nbsp; If we don't do this, we get a warning in the web 
console that content is assumed to be of a particular type.</p>
<p><img border="0" src="note.png" width="24" height="32">&nbsp; Finally, notice 
that we're indicating a function for performing the actual loading.&nbsp; </p>
<h3>Image Loader</h3>
<pre>/// &lt;summary&gt;
/// Read in an image file and returns a ResponsePacket with the raw data.
/// &lt;/summary&gt;
private ResponsePacket ImageLoader(string fullPath, string ext, ExtensionInfo extInfo)
{
  FileStream fStream = new FileStream(fullPath, FileMode.Open, FileAccess.Read);
  BinaryReader br = new BinaryReader(fStream);
  ResponsePacket ret = new ResponsePacket() { Data = br.ReadBytes((int)fStream.Length), ContentType = extInfo.ContentType };
  br.Close();
  fStream.Close();

  return ret;
}</pre>
<h3>File Loader</h3>
<pre>/// &lt;summary&gt;
/// Read in what is basically a text file and return a ResponsePacket with the text UTF8 encoded.
/// &lt;/summary&gt;
private ResponsePacket FileLoader(string fullPath, string ext, ExtensionInfo extInfo)
{
  string text = File.ReadAllText(fullPath);
  ResponsePacket ret = new ResponsePacket() { Data = Encoding.UTF8.GetBytes(text), ContentType = extInfo.ContentType, Encoding = Encoding.UTF8 };

  return ret;
}</pre>
<h3>Page Loader</h3>
<p>The page loader has to do some fancy footwork to handle options like:</p>
<ul>
	<li>foo.com</li>
	<li>foo.com\index</li>
	<li>foo.com\index.html</li>
</ul>
<p>All of these combinations end up load Pages\index.html.</p>
<pre>/// &lt;summary&gt;
/// Load an HTML file, taking into account missing extensions and a file-less IP/domain, 
/// which should default to index.html.
/// &lt;/summary&gt;
private ResponsePacket PageLoader(string fullPath, string ext, ExtensionInfo extInfo)
{
  ResponsePacket ret = new ResponsePacket();

  if (fullPath == WebsitePath) // If nothing follows the domain name or IP, then default to loading index.html.
  {
    ret = Route(GET, &quot;/index.html&quot;, null);
  }
  else
  {
    if (String.IsNullOrEmpty(ext))
    {
      // No extension, so we make it &quot;.html&quot;
      fullPath = fullPath + &quot;.html&quot;;
    }

    // Inject the &quot;Pages&quot; folder into the path
    fullPath = WebsitePath + &quot;\\Pages&quot; + fullPath.RightOf(WebsitePath);
    ret = FileLoader(fullPath, ext, extInfo);
  }

  return ret;
}</pre>
<p>We have a couple helper classes:</p>
<pre>public class ResponsePacket
{
  public string Redirect { get; set; }
  public byte[] Data { get; set; }
  public string ContentType { get; set; }
  public Encoding Encoding { get; set; }
}

internal class ExtensionInfo
{
  public string ContentType { get; set; }
  public Func&lt;string, string, string, ExtensionInfo, ResponsePacket&gt; Loader { get; set; }
}</pre>
<p>And after putting it all together, we have the beginnings of a router, which 
now returns content located in files.</p>
<pre>public ResponsePacket Route(string verb, string path, Dictionary&lt;string, string&gt; kvParams)
{
  string ext = path.RightOf('.');
  ExtensionInfo extInfo;
  ResponsePacket ret = null;

  if (extFolderMap.TryGetValue(ext, out extInfo))
  {
    // Strip off leading '/' and reformat as with windows path separator.
    string fullPath = Path.Combine(WebsitePath, path);
    ret = extInfo.Loader(fullPath, ext, extInfo);
  }

  return ret;
}</pre>
<p>
<img border="0" src="refactor.png" width="32" height="31">&nbsp; We need one final refactoring -- removing our test response and replacing it 
with the content returned by the router:</p>
<pre>private static void Respond(HttpListenerResponse response, ResponsePacket resp)
{
  response.ContentType = resp.ContentType;
  response.ContentLength64 = resp.Data.Length;
  response.OutputStream.Write(resp.Data, 0, resp.Data.Length);
  response.ContentEncoding = resp.Encoding;
  response.StatusCode = (int)HttpStatusCode.OK;
  response.OutputStream.Close();
}</pre>
<p><b>This is bare-bones implementation for now.</b></p>
<p>We can see this in action.&nbsp; Here's some HTML:</p>
<pre>&lt;!DOCTYPE html&gt;

&lt;html lang=&quot;en&quot; xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;utf-8&quot; /&gt;
  &lt;script type=&quot;text/javascript&quot; src=&quot;/Scripts/jquery-1.11.2.min.js&quot;&gt;&lt;/script&gt;
  &lt;link type=&quot;text/css&quot; rel=&quot;Stylesheet&quot; href=&quot;/CSS/demo.css&quot;/&gt;
  &lt;title&gt;Button Click Demo&lt;/title&gt;

  &lt;script type=&quot;text/javascript&quot;&gt;
    $(document).ready(function () {
      $(&quot;#me&quot;).click(function () {
        alert(&quot;I've been clicked!&quot;);
      });
    });
  &lt;/script&gt;
&lt;/head&gt;

&lt;body&gt;
  &lt;div class=&quot;center-inner top-margin-50&quot;&gt;
    &lt;input class=&quot;button&quot; type=&quot;button&quot; value=&quot;Click Me&quot; id=&quot;me&quot;/&gt;
  &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>
<p>You can see the website structure:</p>
<p><img border="0" src="ws5.png" width="264" height="292"></p>
<p>And our little demo page works!</p>
<p><img border="0" src="ws4.png" width="376" height="375"></p>
<p>You can see several things going on here:</p>
<ol>
	<li>Yes indeed, favicon.ico is being loaded (it's a palm tree, if you were 
	wondering)</li>
	<li>The page is of course being loaded</li>
	<li>The styling is working</li>
	<li>The JQuery script is working</li>
</ol>
<p>This is all fine and dandy, but:</p>
<ul>
	<li>Unknown extensions are not handled</li>
	<li>Missing content is not handled</li>
	<li>Errors loading content are not handled</li>
	<li>The verb is always assumed to be &quot;get&quot;</li>
	<li>The application isn't given any option to manipulate the content 
	(particularly the HTML) after it's been loaded</li>
	<li>You can't override the routing</li>
	<li>There's not concept of authorized content</li>
	<li>There's no session duration considered</li>
	<li>There's no exception handling</li>
	<li>Redirects are not handled</li>
</ul>
<p>These are all issues that we need to address, however, we can at this point 
create some pages with CSS and Javascript:, so, even though there's a lot of things to still work on, we do at this point 
have a lot working!</p>
<p><img border="0" src="key-small.jpg" width="94" height="33"></p>
<p>One of the things revealed here is how the actual location of the content 
&quot;file&quot; can be completely spoofed by the server.&nbsp; In the above code, I put 
all the HTML content under the folder Pages, thus spoofing the root location.&nbsp; 
We could do other things -- load data from a database, communicate with another 
server, generate the page dynamically from data...these are all features will 
explore as we move beyond default content loading.</p>
<h2>Step 4 - The Devil is in the Details</h2>
<p>Let's start dealing with the issues mentioned above.</p>
<h3>Error Pages</h3>
<p>We'll add several error pages, even though we're not using them all at the 
moment:</p>
<ul>
	<li>Expired session</li>
	<li>Not authorized</li>
	<li>Page not found</li>
	<li>Server error</li>
	<li>Unknown type</li>
</ul>
<p>Now, you may wonder why the server knows things about expired sessions and 
authorization failures.&nbsp; Well, because it makes sense -- these errors are 
integral to the routing, but the error state is determined by the web 
application (not the server.)&nbsp; All the server does is query the web 
application for the state.&nbsp; More on this later. </p>
<p>We'd like the application to be determine where these pages are for the given 
error, so we'll add an enum to the server:</p>
<pre>public enum ServerError
{
  OK,
  ExpiredSession,
  NotAuthorized,
  FileNotFound,
  PageNotFound,
  ServerError,
  UnknownType,
}</pre>
<p>We can now begin to handle errors (without throwing exceptions).&nbsp; First 
off is an unknown extension:</p>
<pre>if (extFolderMap.TryGetValue(ext, out extInfo))
{
 ...
}
else
{
  ret = new ResponsePacket() { Error = Server.ServerError.UnknownType };
}</pre>
<p>and so forth.&nbsp; We'll use a callback that the web application can provide 
for handling errors.&nbsp; This is in the form of the page to which the user 
should be redirected.</p>
<p>
<img border="0" src="refactor.png" width="32" height="31">&nbsp; We then refactor our code to get, from the application, the page to display 
on error:</p>
<pre>ResponsePacket resp = router.Route(verb, path, kvParams);

if (resp.Error != ServerError.OK)
{
  resp = router.Route(&quot;get&quot;, onError(resp.Error), null);
}

Respond(context.Response, resp);</pre>
<p>and implement a straight forward error handler in the application:</p>
<pre>public static string ErrorHandler(Server.ServerError error)
{
  string ret = null;

  switch (error)
  {
    case Server.ServerError.ExpiredSession:
      ret= &quot;/ErrorPages/expiredSession.html&quot;;
      break;
    case Server.ServerError.FileNotFound:
      ret = &quot;/ErrorPages/fileNotFound.html&quot;;
      break;
    case Server.ServerError.NotAuthorized:
      ret = &quot;/ErrorPages/notAuthorized.html&quot;;
      break;
    case Server.ServerError.PageNotFound:
      ret = &quot;/ErrorPages/pageNotFound.html&quot;;
      break;
    case Server.ServerError.ServerError:
      ret = &quot;/ErrorPages/serverError.html&quot;;
      break;
    case Server.ServerError.UnknownType:
      ret = &quot;/ErrorPages/unknownType.html&quot;;
      break;
  }

  return ret;
}</pre>
<p>Of course, we have to initialize the error handler:</p>
<pre>Server.onError = ErrorHandler;</pre>
<p>We can now test a few things out.&nbsp; Of course, your application may want 
some more sophisticated messages!</p>
<h4>Unknown Type Error</h4>
<p><img border="0" src="error1.png" width="380" height="194"></p>
<h4>Page Not Found</h4>
<h4>
<img border="0" src="error3.png" width="377" height="259"></h4>
<h4>File Not Found</h4>
<p>
<img border="0" src="error4.png" width="377" height="259"></p>
<h3>Redirects</h3>
<p>You'll note that the URL in the above error messages hasn't changed to 
reflect the page.&nbsp; This is because we don't have response redirect working.&nbsp; 
Time to fix that:</p>
<p>We assume that the error handler will always redirect us to a different page, 
so we change how we handle the response.&nbsp; Rather than getting a new 
<code>ResponsePacket</code> and sending that content back to the browser, we simply set the 
<code>Redirect</code> property to the page the web application wants us to go to.&nbsp; This 
becomes, by the way, a universal redirect mechanism.)</p>
<pre>if (resp.Error != ServerError.OK)
{
  resp.Redirect = onError(resp.Error);
}</pre>
<p>
<img border="0" src="refactor.png" width="32" height="31">&nbsp; and we do a little refactoring in the <code>Resond</code> method:</p>
<pre>private static void Respond(HttpListenerRequest request, HttpListenerResponse response, ResponsePacket resp)
{
  if (String.IsNullOrEmpty(resp.Redirect))
  {
    response.ContentType = resp.ContentType;
    response.ContentLength64 = resp.Data.Length;
    response.OutputStream.Write(resp.Data, 0, resp.Data.Length);
    response.ContentEncoding = resp.Encoding;
    response.StatusCode = (int)HttpStatusCode.OK;
  }
  else
  {
    response.StatusCode = (int)HttpStatusCode.Redirect;
    response.Redirect(&quot;http://&quot; + request.UserHostAddress + resp.Redirect);
  }

  response.OutputStream.Close();
}</pre>
<p><img border="0" src="note.png" width="24" height="32">&nbsp; By the way, it's 
very important to close the output stream.&nbsp; If you don't, the browser can 
be left hanging, waiting for data.</p>
<p><img border="0" src="note.png" width="24" height="32">&nbsp; Notice that 
since we're handling errors with redirects, the only two possible status codes 
our web server can respond with is OK and Redirect.</p>
<p>Now our redirecting is working:</p>
<p><img border="0" src="error2.png" width="377" height="259"></p>
<h4>Exception Handling</h4>
<p>We use the same redirect mechanism to catch actual exceptions by wrapping the 
<code>GetContextAsync</code> continuation in a try-catch block:</p>
<pre>catch(Exception ex)
{
  Console.WriteLine(ex.Message);
  Console.WriteLine(ex.StackTrace);
  resp = new ResponsePacket() { Redirect = onError(ServerError.ServerError) };
}</pre>
<p>Here's what a simulated error looks like:</p>
<p><img border="0" src="error5.png" width="791" height="424"></p>
<h2>Step 5 - Review and Tackle More Issues</h2>
<p>Where are we?</p>
<ul>
	<li><strike>Unknown extensions are not handled</strike></li>
	<li><strike>Missing content is not handled</strike></li>
	<li><strike>Errors loading content are not handled</strike></li>
	<li>The verb is always assumed to be &quot;get&quot;</li>
	<li>The application isn't given any option to manipulate the content 
	(particularly the HTML) after it's been loaded</li>
	<li>You can't override the routing</li>
	<li>There's not concept of authorized content</li>
	<li>There's no session duration considered</li>
	<li><strike>There's no exception handling</strike></li>
	<li><strike>Redirects are not handled</strike></li>
</ul>
<p>Let's deal with verbs next, particularly POST verbs.&nbsp; This will allow us 
to tackle the next three live bullet items.</p>
<h3>Verbs</h3>
<p>There are <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html">
several verbs</a> that can accompany an HTTP request:</p>
<ul>
	<li>OPTIONS</li>
	<li>GET</li>
	<li>HEAD</li>
	<li>POST</li>
	<li>PUT</li>
	<li>DELETE</li>
	<li>TRACE</li>
	<li>CONNECT</li>
</ul>
<p>Essentially, the web server doesn't really care about the verb -- all the 
verb does is provide additional information as to what handler to invoke for the 
response.&nbsp; Here we finally get to a topic I've avoided so far -- 
controllers.&nbsp; Rather than the web server having any cognizance of a 
Model-View-Controller pattern and/or enforcing such pattern on the web 
application developer, the web server I've implemented provides a simple 
mechanism for routing verbs and paths to handlers.&nbsp; That's all it needs to 
do.&nbsp; The handler, in turn, determines whether the browser should be 
redirected to a different page or stay on the current page.&nbsp; Behind the 
scenes, the handler can do other things, but from the perspective of the web 
server, that's all that the web server cares about.</p>
<h3>Routes</h3>
<p>We'll begin by adding a basic router.&nbsp; This consists of a <code>Route</code> class:</p>
<pre>public class Route
{
  public string Verb { get; set; }
  public string Path { get; set; }
  public Func&lt;Dictionary&lt;string,string&gt;, string&gt; Action { get; set; }
}</pre>
<p>Notice the Action property, which is a callback function that passes in the 
URL parameters (we'll deal with post parameters in a bit) and expects an 
&quot;optional&quot; redirect URL.</p>
<p>We add a simple method to add routes to a route table:</p>
<pre>public void AddRoute(Route route)
{
  routes.Add(route);
}</pre>
<p>
<img border="0" src="refactor.png" width="32" height="31">&nbsp; Now we can implement calling application specific handlers, which is a 
refactor of the Route method:</p>
<pre>public ResponsePacket Route(string verb, string path, Dictionary&lt;string, string&gt; kvParams)
{
  string ext = path.RightOfRightmostOf('.');
  ExtensionInfo extInfo;
  ResponsePacket ret = null;
  verb = verb.ToLower();

  if (extFolderMap.TryGetValue(ext, out extInfo))
  {
    string wpath = path.Substring(1).Replace('/', '\\'); // Strip off leading '/' and reformat as with windows path separator.
    string fullPath = Path.Combine(WebsitePath, wpath);

    Route route = routes.SingleOrDefault(r =&gt; verb == r.Verb.ToLower() &amp;&amp; path == r.Path);

    if (route != null)
    {
      // Application has a handler for this route.
      string redirect = route.Action(kvParams);

      if (String.IsNullOrEmpty(redirect))
      {
        // Respond with default content loader.
        ret = extInfo.Loader(fullPath, ext, extInfo);
      }
      else
      {
        // Respond with redirect.
        ret = new ResponsePacket() { Redirect = redirect };
      }
    }
    else
    {
      // Attempt default behavior
      ret = extInfo.Loader(fullPath, ext, extInfo);
    }
  }
  else
  {
    ret = new ResponsePacket() { Error = Server.ServerError.UnknownType };
  }

  return ret;
}</pre>
<p>Now let's modify our demo page to make a POST call to the server when we 
click the button, and we'll redirect to a different page in our handler.&nbsp; 
Yes, I know this could be handled entirely in the Javascript, but we're 
demonstrating verb-path handlers here, so we'll implement this behavior on the 
server-side.</p>
<p>Let's also add processing the input stream of the request into key-value 
pairs as well, and add logging of the parameters (both in the URL and any 
parameters in the input stream) that is part of the request:</p>
<pre>private static async void StartConnectionListener(HttpListener listener)
{
  ...
  Dictionary&lt;string, string&gt; kvParams = GetKeyValues(parms); // Extract into key-value entries.
  string data = new StreamReader(context.Request.InputStream, context.Request.ContentEncoding).ReadToEnd();
  GetKeyValues(data, kvParams);
  Log(kvParams);
  ...
}

private static Dictionary&lt;string, string&gt; GetKeyValues(string data, Dictionary&lt;string, string&gt; kv = null)
{
  kv.IfNull(() =&gt; kv = new Dictionary&lt;string, string&gt;());
  data.If(d =&gt; d.Length &gt; 0, (d) =&gt; d.Split('&amp;').ForEach(keyValue =&gt; kv[keyValue.LeftOf('=')] = keyValue.RightOf('=')));

  return kv;
}

private static void Log(Dictionary&lt;string, string&gt; kv)
{
  kv.ForEach(kvp=&gt;Console.WriteLine(kvp.Key+&quot; : &quot;+kvp.Value));
}</pre>
<p>It may be a bad practice to combine URL parameters and postback parameters 
into a single key-value pair collection, but we'll go with this &quot;simpler&quot; 
implementation for now.</p>
<p>We create a new HTML page /demo/redirect:</p>
<pre>&lt;!DOCTYPE html&gt;

&lt;html lang=&quot;en&quot; xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;utf-8&quot; /&gt;
  &lt;title&gt;Redirect Demo&lt;/title&gt;
  &lt;link type=&quot;text/css&quot; rel=&quot;Stylesheet&quot; href=&quot;/CSS/demo.css&quot;/&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;form name=&quot;myform&quot; action=&quot;/demo/redirect&quot; method=&quot;post&quot;&gt;
    &lt;div class=&quot;center-inner top-margin-50&quot;&gt;
      &lt;input type=&quot;submit&quot; class=&quot;button&quot; value=&quot;Redirect Me&quot; id='redirect' name=&quot;redirectButton&quot; /&gt;
    &lt;/div&gt;
  &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>
<p>And, without doing anything further, let's look at the trace log and the 
behavior when we click on the button:</p>
<p>
<img border="0" src="redirect1.png" width="439" height="401"></p>
<p>First we see the GET verb as the page loads, then, clicking on the button, we 
see the POST with the parameters.&nbsp; The fun thing about writing your own web 
server is you really get a deeper sense of what is happening behind the scenes, 
something that is important for people who are new to web development.&nbsp; 
Note the following in relation to the HTML:</p>
<p>
<img border="0" src="redirect2.png" width="675" height="361"></p>
<ol>
	<li>The method verb must be in lowercase.&nbsp; If you use &quot;POST&quot;, Visual 
	Studio's IDE warns that this is an unrecognized HTML5 verb.</li>
	<li>Ironically, the verb in the HttpListenerRequest.HttpMethod property is 
	in uppercase!</li>
	<li>Note how the action path is the HttpListenerRequest.Url.AbsoluteUri</li>
	<li>Note the way the post data is packaged.&nbsp; The &quot;key&quot; is the HTML 
	element's name and the &quot;value&quot; is the HTML element's value.&nbsp; Observe 
	how whitespaces in the value have been replaced with '+'.</li>
</ol>
<p>Now let's register a handler for this verb and path:</p>
<pre>static void Main(string[] args)
{
  string websitePath = GetWebsitePath();
  Server.onError = ErrorHandler;

  // register a route handler:
  Server.AddRoute(new Route() { Verb = Router.POST, Path = &quot;/demo/redirect&quot;, Action = RedirectMe });

  Server.Start(websitePath);
  Console.ReadLine();
}

public static string RedirectMe(Dictionary&lt;string, string&gt; parms)
{
  return &quot;/demo/clicked&quot;;
}</pre>
<p>And now, when&nbsp; we click the button, we're redirected:</p>
<p>
<img border="0" src="redirect3.png" width="425" height="365"></p>
<p>That was easy.&nbsp; </p>
<p>
<img border="0" src="refactor.png" width="32" height="31">&nbsp; With a minimal amount of refactoring, we've take care of 
these three issues:</p>
<ul>
	<li>The verb is always assumed to be &quot;get&quot;</li>
	<li>The application isn't given any option to manipulate the content 
	(particularly the HTML) after it's been loaded</li>
	<li>You can't override the routing</li>
</ul>
<h2>Step 6 - Authentication and Session Expiration</h2>
<p>In step 5 above, I implemented a very basic route handler.&nbsp; What we'd 
like is something a little more sophisticated that can handle very common tasks:</p>
<ul>
	<li>making sure the user is authorized to view the page</li>
	<li>checking if the session has expired</li>
</ul>
<p>
<img border="0" src="refactor.png" width="32" height="31">&nbsp; We'll refactor the handler callbacks above to utilize a Routing class from 
which we can provide some built-in behaviors as well as allowing the web 
application developer to replace and/or add their own additional behaviors, such 
as role-based authentication.</p>
<h3>Session Management</h3>
<p>First, let's add a basic <code>Session</code> and <code>SessionManager</code> class:</p>
<pre>using System;
using System.Collections.Generic;
using System.Linq;
using System.Net;
using System.Text;
using System.Threading.Tasks;

using Clifton.ExtensionMethods;

namespace Clifton.WebServer
{
  /// &lt;summary&gt;
  /// Sessions are associated with the client IP.
  /// &lt;/summary&gt;
  public class Session
  {
    public DateTime LastConnection { get; set; }
    public bool Authorized { get; set; }

    /// &lt;summary&gt;
    /// Can be used by controllers to add additional information that needs to persist in the session.
    /// &lt;/summary&gt;
    public Dictionary&lt;string, string&gt; Objects { get; set; }

    public Session()
    {
      Objects = new Dictionary&lt;string, string&gt;();
      UpdateLastConnectionTime();
    }

    public void UpdateLastConnectionTime()
    {
      LastConnection = DateTime.Now;
    }


    /// &lt;summary&gt;
    /// Returns true if the last request exceeds the specified expiration time in seconds.
    /// &lt;/summary&gt;
    public bool IsExpired(int expirationInSeconds)
    {
      return (DateTime.Now - LastConnection).TotalSeconds &gt; expirationInSeconds;
    }
  }

  public class SessionManager
  {
    /// &lt;summary&gt;
    /// Track all sessions.
    /// &lt;/summary&gt;
    protected Dictionary&lt;IPAddress, Session&gt; sessionMap = new Dictionary&lt;IPAddress, Session&gt;();

    // TODO: We need a way to remove very old sessions so that the server doesn't accumulate thousands of stale endpoints.

    public SessionManager()
    {
      sessionMap = new Dictionary&lt;IPAddress, Session&gt;();
    }

    /// &lt;summary&gt;
    /// Creates or returns the existing session for this remote endpoint.
    /// &lt;/summary&gt;
    public Session GetSession(IPEndPoint remoteEndPoint)
    {
      // The port is always changing on the remote endpoint, so we can only use IP portion.
      Session session = sessionMap.CreateOrGet(remoteEndPoint.Address);

      return session;
    }
  }
}    </pre>
<p>The <code>SessionManager</code> manages <code>Session</code> instances associated with the client's 
endpoint IP.&nbsp; Note the todo--that we need some way of removing sessions at 
some point, otherwise this list will just keep growing!&nbsp; The Session class 
contains a couple useful properties for managing the last connection date/time 
as well as whether the user has been authorized (logged in, whatever) to view 
&quot;authorized&quot; pages.&nbsp; We also provide a key-value pair dictionary for the 
web application to persist &quot;objects&quot; associated with keys.&nbsp; Basic, but 
functional.</p>
<p>Now, in our listener continuation, we can get the session associated with the 
endpoint IP:</p>
<pre>private static async void StartConnectionListener(HttpListener listener)
{
  ResponsePacket resp = null;

  // Wait for a connection. Return to caller while we wait.
  HttpListenerContext context = await listener.GetContextAsync();</pre>
<pre>  Session session = sessionManager.GetSession(context.Request.RemoteEndPoint);
  ...
  resp = router.Route(verb, path, kvParams);

  // Update session last connection after getting the response, 
  // as the router itself validates session expiration only on pages requiring authentication.
  session.UpdateLastConnectionTime();</pre>
<p>That was quite easy!&nbsp; Note how we're updating the last connection time 
after giving the router (and our handlers) the option to first inspect the last 
session state.</p>
<p>
<img border="0" src="note.png" width="24" height="32">&nbsp; 
Because session expiration is intimately associated with authorization, we 
expect that when a session expires, the <code>Authorized</code> flag will be cleared.</p>
<h3>Anonymous vs. Authenticated Routes</h3>
<p>Now let's add some built-in functionality for checking authorization and 
session expiration.&nbsp; We'll add three classes to our server that the 
application can use:</p>
<ul>
	<li>AnonymousRouteHandler</li>
	<li>AuthenticatedRouteHandler</li>
	<li>AuthenticatedExpirableRouteHandler</li>
</ul>
<pre>using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Clifton.WebServer
{
  /// &lt;summary&gt;
  /// The base class for route handlers.
  /// &lt;/summary&gt;
  public abstract class RouteHandler
  {
    protected Func&lt;Session, Dictionary&lt;string, string&gt;, string&gt; handler;

    public RouteHandler(Func&lt;Session, Dictionary&lt;string, string&gt;, string&gt; handler)
    {
      this.handler = handler;
    }

    public abstract string Handle(Session session, Dictionary&lt;string, string&gt; parms);
  }

  /// &lt;summary&gt;
  /// Page is always visible.
  /// &lt;/summary&gt;
  public class AnonymousRouteHandler : RouteHandler
  {
    public AnonymousRouteHandler(Func&lt;Session, Dictionary&lt;string, string&gt;, string&gt; handler)
        : base(handler)
    {
    }

    public override string Handle(Session session, Dictionary&lt;string, string&gt; parms)
    {
      return handler(session, parms);
    }
  }

  /// &lt;summary&gt;
  /// Page is visible only to authorized users.
  /// &lt;/summary&gt;
  public class AuthenticatedRouteHandler : RouteHandler
  {
    public AuthenticatedRouteHandler(Func&lt;Session, Dictionary&lt;string, string&gt;, string&gt; handler)
        : base(handler)
    {
    }

    public override string Handle(Session session, Dictionary&lt;string, string&gt; parms)
    {
      string ret;

      if (session.Authorized)
      {
        ret = handler(session, parms);
      }
      else
      {
        ret = Server.onError(Server.ServerError.NotAuthorized);
      }

      return ret;
    }
  }

  /// &lt;summary&gt;
  /// Page is visible only to authorized users whose session has not expired.
  /// &lt;/summary&gt;
  public class AuthenticatedExpirableRouteHandler : AuthenticatedRouteHandler
  {
    public AuthenticatedExpirableRouteHandler(Func&lt;Session, Dictionary&lt;string, string&gt;, string&gt; handler)
        : base(handler)
    {
    }

    public override string Handle(Session session, Dictionary&lt;string, string&gt; parms)
    {
      string ret;

      if (session.IsExpired(Server.expirationTimeSeconds))
      {
        session.Authorized = false;
        ret = Server.onError(Server.ServerError.ExpiredSession);
      }
      else
      {
        ret = base.Handle(session, parms);
      }

      return ret;
    }
  }
}</pre>
<p>Notice that we also now pass the session instance to the handler.&nbsp; 
Convenient!</p>
<p>
<img border="0" src="refactor.png" width="32" height="31">&nbsp; Next, we refactor the web application routing table to use the <code>RouteHandler</code> 
derived classes.&nbsp; Our Route class is refactored:</p>
<pre>public class Route
{
  public string Verb { get; set; }
  public string Path { get; set; }
  public RouteHandler Handler { get; set; }
}</pre>
<p>The session is now passed in to the router and handed over to the route 
handler:</p>
<pre>public ResponsePacket Route(Session session, string verb, string path, Dictionary&lt;string, string&gt; kvParams)
{
  ...
  string redirect = route.Handler.Handle(session, kvParams);
  ...</pre>
<p>Now we just need to update our web application by specifying the type of 
handler, for example:</p>
<p>Server.AddRoute(new Route() { Verb = Router.POST, Path = &quot;/demo/redirect&quot;, 
Handler=new AnonymousRouteHandler(RedirectMe) });</p>
<p>and of course, our handler now receives the session instance:</p>
<pre>public static string RedirectMe(Session session, Dictionary&lt;string, string&gt; parms)
{
  return &quot;/demo/clicked&quot;;
}</pre>
<p>Let's create a route that requires authorization but the authorization flag is 
not set in the session:</p>
<pre>Server.AddRoute(new Route() 
  { 
    Verb = Router.POST, 
    Path = &quot;/demo/redirect&quot;, 
    Handler=new AuthenticatedRouteHandler(RedirectMe) 
  });</pre>
<p>We'll click on the &quot;Redirect Me&quot; button, and note that we get the &quot;not 
authorized&quot; page:</p>
<p>
<img border="0" src="auth1.png" width="370" height="241"></p>
<p>We'll do the same thing to test the expiration logic: </p>
<pre>Server.AddRoute(new Route() 
  { 
    Verb = Router.POST, 
    Path = &quot;/demo/redirect&quot;, 
    Handler=new AuthenticatedExpirableRouteHandler(RedirectMe) 
  });</pre>
<p>and after waiting 60 seconds (configurable in the Server) on the &quot;Redirect 
Me&quot; page:</p>
<p>
<img border="0" src="exp1.png" width="380" height="270"></p>
<p>While building a website, I find that authentication/expiration often gets in 
the way, so I like to spoof the authentication.&nbsp; We can do that by 
implementing onRequest, which the server calls if it exists:</p>
<pre>public static Action&lt;Session, HttpListenerContext&gt; onRequest;
...
  // Wait for a connection. Return to caller while we wait.
  HttpListenerContext context = await listener.GetContextAsync();
  Session session = sessionManager.GetSession(context.Request.RemoteEndPoint);
  onRequest.IfNotNull(r =&gt; r(session, context));</pre>
<p>and we can implement our &quot;always authorized and never expiring&quot; session this 
way:</p>
<pre>static void Main(string[] args)
{
  string websitePath = GetWebsitePath();
  Server.onError = ErrorHandler;

  // Never expire, always authorize
  Server.onRequest = (session, context) =&gt;
  {
    session.Authorized = true;
    session.UpdateLastConnectionTime();
  };
</pre>
<h2>Step 7 - AJAX Queries</h2>
<p>Let's look at an AJAX callback to see if there's anything we need to do to 
handle that.&nbsp; We'll put together an HTML page with a simple AJAX jQuery 
script:</p>
<pre>&lt;html lang=&quot;en&quot; xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;utf-8&quot; /&gt;
  &lt;title&gt;AJAX Demo&lt;/title&gt;
  &lt;script type=&quot;text/javascript&quot; src=&quot;/Scripts/jquery-1.11.2.min.js&quot;&gt;&lt;/script&gt;
  &lt;link type=&quot;text/css&quot; rel=&quot;Stylesheet&quot; href=&quot;/CSS/demo.css&quot;/&gt;

  &lt;script type=&quot;text/javascript&quot;&gt;
    $(document).ready(function () {
      $(&quot;#me&quot;).click(function () {
        $.ajax({
          url: this.href,
          datatype: &quot;json&quot;,
          async: true,
          cache: false,
          type: &quot;put&quot;,
          data: {
          number: 5
          },
          success: function(data, status)
          {
            alert(data);
          }
        });
      });
    });
&lt;/script&gt;

&lt;/head&gt;
&lt;body&gt;
  &lt;div class=&quot;center-inner top-margin-50&quot;&gt;
    &lt;input class=&quot;button&quot; type=&quot;button&quot; value=&quot;AJAX!&quot; id=&quot;me&quot;/&gt;
  &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>
<p>We can see the request being made, but since we don't have a specific handler 
for this request, we see the server responding with the contents of the page, 
which is expected.</p>
<p>
<img border="0" src="ajax1.png" width="496" height="391"></p>
<p>So let's register a route handler:</p>
<pre>Server.AddRoute(new Route() 
  { 
    Verb = Router.PUT, 
    Path = &quot;/demo/ajax&quot;, 
    Handler = new AnonymousRouteHandler(AjaxResponder) 
  });</pre>
<p>But now we have a problem.&nbsp; Our standard handler expects a redirect, not 
a data response:</p>
<pre>public static string AjaxResponder(Session session, Dictionary&lt;string, string&gt; parms)
{
  return &quot;what???&quot;;
}</pre>
<p>
<img border="0" src="refactor.png" width="32" height="31">&nbsp; 
Yes, it's time for another refactoring.&nbsp; The handler needs finer control 
over the response, and thus should return a <code>ResponsePacket</code>, for 
example:</p>
<pre>public static ResponsePacket RedirectMe(Session session, Dictionary&lt;string, string&gt; parms)
{
  return Server.Redirect(&quot;/demo/clicked&quot;);
}

public static ResponsePacket AjaxResponder(Session session, Dictionary&lt;string, string&gt; parms)
{
  string data = &quot;You said &quot; + parms[&quot;number&quot;];
  ResponsePacket ret = new ResponsePacket() { Data = Encoding.UTF8.GetBytes(data), ContentType = &quot;text&quot; };

  return ret;
}</pre>
<p>This change required touching a few places where the handler response used to 
be a string.&nbsp; The most relevant piece of code changed was in the router 
itself:</p>
<pre>Route handler = routes.SingleOrDefault(r =&gt; verb == r.Verb.ToLower() &amp;&amp; path == r.Path);

if (handler != null)
{
  // Application has a handler for this route.
  ResponsePacket handlerResponse = handler.Handler.Handle(session, kvParams);

  if (handlerResponse == null)
  {
    // Respond with default content loader.
    ret = extInfo.Loader(session, fullPath, ext, extInfo);
  }
  else
  {
    // Respond with redirect.
    ret = handlerResponse;
  }
}</pre>
<p>but the change took all of about 5 minutes, and here's the result:</p>
<p>
<img border="0" src="ajax2.png" width="383" height="346"></p>
<p>You can of course return the data in JSON or XML -- that is completely 
independent of the web server, but you are advised to set the content type 
correctly:</p>
<ul>
	<li>ContentType = &quot;application/json&quot;</li>
	<li>ContentType = &quot;application/xml&quot;</li>
</ul>
<h3>AJAX GET Verb</h3>
<p>Also note that I used the &quot;PUT&quot; verb, which isn't necessarily appropriate, 
but I wanted to use it as an example.&nbsp; Look what happens if instead, we use 
the GET verb:</p>
<p>
<img border="0" src="ajax3.png" width="484" height="458"></p>
<p>With the GET verb, the parameters are passed as part of the URL!&nbsp; Let's 
write a handler for this route:</p>
<pre>Server.AddRoute(new Route() 
  { 
    Verb = Router.GET, 
    Path = &quot;/demo/ajax&quot;, 
    Handler = new AnonymousRouteHandler(AjaxGetResponder) 
  });</pre>
<p>Note that we have to handle the GET verb with both no parameters (the 
browser's request) and with parameters:</p>
<p>
<img border="0" src="ajax4.png" width="364" height="157"></p>
<p>Interestingly, we can use the browser now to test the GET response -- note 
the URL:</p>
<p>
<img border="0" src="ajax5.png" width="292" height="111"></p>
<h3>What's that Underscore?</h3>
<p>The underscore parameter is added by jQuery to get around Internet Explorer's 
caching, and is present only when cache is set to false and you're using the GET 
verb.&nbsp; Ignore it.</p>
<h2>Step 8 - Internet vs. Intranet</h2>
<h3>Local vs. Public IP Addresses</h3>
<p>Testing a web server locally on a 192.168... IP address is fine, but what 
happens when you deploy the site?&nbsp; I did this using an Amazon EC2 server 
and discovered (obivously) that there is a local IP behind the firewall, vs. the 
public IP.&nbsp; You can see the same thing with your router.&nbsp; We can get 
the public IP with this code which I found on Stack Overflow (sorry, I the link 
to give proper credit):</p>
<pre>public static string GetExternalIP()
{
  string externalIP;
  externalIP = (new WebClient()).DownloadString(&quot;http://checkip.dyndns.org/&quot;);
  externalIP = (new Regex(@&quot;\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}&quot;)).Matches(externalIP)[0].ToString();

  return externalIP;
}</pre>
<p>Possibly not the best approach, but it does work.</p>
<p>
<img border="0" src="refactor.png" width="32" height="31">&nbsp; The salient thing here is that, when responding with a redirect, the public 
IP must be used, not the <code>UserHostAddress</code>:</p>
<pre>if (String.IsNullOrEmpty(publicIP))
{
  response.Redirect(&quot;http://&quot; + request.UserHostAddress + resp.Redirect);
}
else
{
  response.Redirect(&quot;http://&quot; + publicIP + resp.Redirect); 
}</pre>
<p>Note that the above code for obtaining the external IP can be a bit slow, and 
should obviously only be done at server startup.&nbsp; Furthermore, it of course 
isn't necessary if you have an actual domain name.&nbsp; However, for testing 
your web application with a host provider without having registered a domain and 
pointing it to the host provider, the above step is absolutely necessary.</p>
<h3>Domain Names</h3>
<p>The above code is fine for testing when you don't have a registered domain 
name, but obviously we don't want the user to see the IP address whenever we do 
a redirect.&nbsp; I haven't testing this with an actual domain name, but the 
guidance here is, simply set <code>publicIP</code> with the actual domain name, 
for example:</p>
<pre>Server.publicIP=&quot;www.yourdomain.com&quot;;</pre>
<h2>Step 9 - So You Want to Modify the HTML Dynamically (and why you ought to)</h2>
<p>As I said in the introduction, with the capabilities of jQuery, AJAX, 
Javascript and professional third party components, I can only rarely imagine 
the need for any complex server-side HTML generation using embedded Ruby or C# 
along with the markup itself.&nbsp; That said, there is one reason you probably 
want the server to modify the HTML, and that is to deal with CSRF attacks.</p>
<h3>Cross-Site Request Forgery (CSRF)</h3>
<p>
<a href="http://blog.stevensanderson.com/2008/09/01/prevent-cross-site-request-forgery-csrf-using-aspnet-mvcs-antiforgerytoken-helper/">
Here's</a> a good explanation of CSRF and why you should care about it.&nbsp; 
However, do we need a runtime dynamic code compilation to spit out the necessary 
HTML?&nbsp; No, of course not.&nbsp; So, to deal with CSRF and more generally, 
server-side HTML manipulation, we'll add the ability for the web application to 
post-process the HTML before it is returned to the browser.&nbsp; We can do this 
in the router just before the HTML is encoded into a byte array:</p>
<pre>string text = File.ReadAllText(fullPath);
text = Server.postProcess(session, text); // post processing option, such as adding a validation token.</pre>
<p>The default implementation provided by the server is:</p>
<pre>public static string validationTokenScript = &quot;&lt;%AntiForgeryToken%&gt;&quot;;
public static string validationTokenName = &quot;__CSRFToken__&quot;;

private static string DefaultPostProcess(Session session, string html)
{
  string ret = html.Replace(validationTokenScript, 
    &quot;&lt;input name='&quot; + 
    validationTokenName + 
    &quot;' type='hidden' value='&quot; + 
    session.Objects[validationTokenName].ToString() + 
    &quot; id='#__csrf__'&quot; +
    &quot;/&gt;&quot;);

  return ret;
}</pre>
<p>
<img border="0" src="refactor.png" width="32" height="31">&nbsp; 
Refactoring time!&nbsp; A token is created when a new session is encountered:</p>
<pre>public Session GetSession(IPEndPoint remoteEndPoint)
{
  Session session;

  if (!sessionMap.TryGetValue(remoteEndPoint.Address, out session))
  {
    session=new Session();
    session.Objects[Server.validationTokenName] = Guid.NewGuid().ToString();
    sessionMap[remoteEndPoint.Address] = session;
  }

  return session;
}</pre>
<p>We can then, by default, implement a CSRF check on non-GET verbs (though we 
should probably be more selective than that, for the moment I'll just leave it 
at that):</p>
<pre>public ResponsePacket Route(Session session, string verb, string path, Dictionary&lt;string, string&gt; kvParams)
{
  string ext = path.RightOfRightmostOf('.');
  ExtensionInfo extInfo;
  ResponsePacket ret = null;
  verb = verb.ToLower();

  if (verb != GET)
  {
    if (!VerifyCSRF(session, kvParams))
    {
      // Don't like multiple return points, but it's so convenient here!
      return Server.Redirect(Server.onError(Server.ServerError.ValidationError));
    }
  }
  ...
}

/// &lt;summary&gt;
/// If a CSRF validation token exists, verify it matches our session value.
/// If one doesn't exist, issue a warning to the console.
/// &lt;/summary&gt;
private bool VerifyCSRF(Session session, Dictionary&lt;string,string&gt; kvParams)
{
  bool ret = true;
  string token;

  if (kvParams.TryGetValue(Server.validationTokenName, out token))
  {
    ret = session.Objects[Server.validationTokenName].ToString() == token;
  }
  else
  {
    Console.WriteLine(&quot;Warning - CSRF token is missing. Consider adding it to the request.&quot;);
  }

  return ret;
}</pre>
<p>So, given this HTML:</p>
<pre>&lt;!DOCTYPE html&gt;

&lt;html lang=&quot;en&quot; xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;utf-8&quot; /&gt;
  &lt;title&gt;Login&lt;/title&gt;
  &lt;link type=&quot;text/css&quot; rel=&quot;Stylesheet&quot; href=&quot;/CSS/demo.css&quot;/&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;form name=&quot;myform&quot; action=&quot;/demo/redirect&quot; method=&quot;post&quot;&gt;
    &lt;%AntiForgeryToken%&gt;
    &lt;div class=&quot;center-inner top-margin-50&quot;&gt;
      Username:&amp;nbsp;
      &lt;input name=&quot;username&quot;/&gt;
    &lt;/div&gt;
    &lt;div class=&quot;center-inner top-margin-10&quot;&gt;
      Password:&amp;nbsp;
      &lt;input type=&quot;password&quot; name=&quot;password&quot;/&gt;
    &lt;/div&gt;
    &lt;div class=&quot;center-inner top-margin-10&quot;&gt;
      &lt;input type=&quot;submit&quot; value=&quot;Login&quot;/&gt;
    &lt;/div&gt;
  &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>
<p>
<img border="0" src="csrf1.png" width="340" height="298"></p>
<p>We can inspect the source and see our token, for example:</p>
<pre>&lt;form name=&quot;myform&quot; action=&quot;/demo/redirect&quot; method=&quot;post&quot;&gt;
  &lt;input name='__CSRFToken__' type='hidden' value='a9161119-de6f-4bb2-8e21-8d089d556c37'/&gt;</pre>
<p>And in the console window, on the post, we see:</p>
<p>
<img border="0" src="csrf2.png" width="327" height="176"></p>
<p>If we omit the validation token, we get a warning in the console window:</p>
<p>
<img border="0" src="csrf3.png" width="421" height="190"></p>
<h3>Other HTML Replacement</h3>
<p>When you have finer grained control over the server, you can pretty much do 
anything you want in terms of inventing your own set of token replacements.&nbsp; 
You could even feed the HTML to different parsers.&nbsp; For example, I really 
like the <a href="http://slim-lang.com/">Slim language template</a> supported in 
Ruby on Rails.&nbsp; For example, in the Slim syntax, the login HTML looks like 
this:</p>
<pre>doctype html
html lang=&quot;en&quot; xmlns=&quot;<a href="http://www.w3.org/1999/xhtml">http://www.w3.org/1999/xhtml</a>&quot; 
  head
    meta charset=&quot;utf-8&quot; /
    title Login
    link href=&quot;/CSS/demo.css&quot; rel=&quot;Stylesheet&quot; type=&quot;text/css&quot; /
  body
    form action=&quot;/demo/redirect&quot; method=&quot;post&quot; name=&quot;myform&quot; 
      | &lt;%AntiForgeryToken%
      .center-inner.top-margin-50
        | Username:&amp;nbsp;
        input name=&quot;username&quot; /
      .center-inner.top-margin-10
        | Password:&amp;nbsp;
        input name=&quot;password&quot; type=&quot;password&quot; /
      .center-inner.top-margin-10
        input type=&quot;submit&quot; value=&quot;Login&quot; /</pre>
<p>This is not available with ASP.NET, Razor, etc., and replacing the Razor 
parser engine is not trivial.&nbsp; However, we can easily add a Slim to HTML 
post-process parser to <i>our</i> web server.</p>
<h2>Issues for Another Day</h2>
<h3>CSRF and AJAX</h3>
<p>Because of where we put this check in, we will get this warning on AJAX 
post/put/deletes as well, which is probably a good idea.&nbsp; Here's what our 
AJAX demo page looks like passing in the CSRF token:</p>
<pre>&lt;script type=&quot;text/javascript&quot;&gt;
  $(document).ready(function () {
    $(&quot;#me&quot;).click(function () {
      $.ajax({
        url: this.href,
        async: true,
        cache: false,
        type: &quot;put&quot;,
        data: {
          number: 5,
          __CSRFToken__: $(&quot;#__csrf__&quot;).val()
        },
        success: function(data, status)
        {
          alert(data);
        }
      });
    });
  });
&lt;/script&gt;</pre>
<p>This is probably not your typical implementation and it also results in some 
interesting browser behavior if the validation fails (sending a redirect as an 
AJAX response is a bit weird.)&nbsp; In any 
case, this becomes a rabbit hole that I don't want to pursue further and will 
leave it to the reader to decide whether AJAX requests should have a validation 
token.&nbsp; If you leave it off, then the console will simply issue a warning.</p>
<h3>HTTPS</h3>
<p>Websites should really use HTTPS nowadays, however I'm am going to leave this 
for another day, possibly a separate article or an addendum at some point to 
this article.</p>
<h3>Decoding Parameter Values</h3>
<p>It would probably be nice to decode parameter values, for example, replacing 
&quot;+&quot; with whitespace and &quot;%xx&quot; with the appropriate actual character.</p>
<h3>Chaining Post Processing</h3>
<p>Post processing the HTML is one of those things ripe for chaining, and is on 
the todo list.</p>
<h3>What Else?</h3>
<p>I'm sure there's other things that could be done!</p>
<h2>Conclusion</h2>
<p>What other major issues need to be taken care of?&nbsp; What horrendous 
mistakes did I make?</p>
<p>The idea is to keep the web server very small.&nbsp; I have a total of four 
classes (not including extension methods) and the whole thing is slightly less 
than 650 lines of code, comments and all.</p>

</body>

</html>